// SPDX-License-Identifier: BUSL-1.1

pragma solidity 0.8.20;

import "../interfaces/IYieldToken.sol";
import "../interfaces/IPrincipalToken.sol";
import "../interfaces/IRegistry.sol";
import "openzeppelin-contracts/interfaces/IERC4626.sol";
import "openzeppelin-math/Math.sol";
import "../libraries/RayMath.sol";

library PrincipalTokenUtil {
    using Math for uint256;
    using RayMath for uint256;

    error AssetDoesNotImplementMetadata();

    uint256 private constant SAFETY_BOUND = 100; // used to favour the protocol in case of approximations
    uint256 private constant FEE_DIVISOR = 1e18; // equivalent to 100% fees

    /** @dev See {IPrincipalToken-convertToSharesWithRate}. */
    function _convertToSharesWithRate(
        uint256 _assets,
        uint256 _rate,
        uint256 _ibtUnit,
        Math.Rounding _rounding
    ) internal pure returns (uint256 shares) {
        if (_rate == 0) {
            revert IPrincipalToken.RateError();
        }
        return _assets.mulDiv(_ibtUnit, _rate, _rounding);
    }

    /** @dev See {IPrincipalToken-convertToAssetsWithRate}. */
    function _convertToAssetsWithRate(
        uint256 _shares,
        uint256 _rate,
        uint256 _ibtUnit,
        Math.Rounding _rounding
    ) internal pure returns (uint256 assets) {
        return _shares.mulDiv(_rate, _ibtUnit, _rounding);
    }

    /**
     * @dev Computes the yield for a specified user since the last update.
     * @param _user The address for which the yield is to be calculated.
     * @param _userYieldIBT the current yield of user in IBT
     * @param _oldIBTRate the previous deposit IBT rate of user (in Ray)
     * @param _ibtRate the current IBT rate (in Ray)
     * @param _oldPTRate the previous deposit pt rate of user (in Ray)
     * @param _ptRate the current PT rate (in Ray)
     * @param _yt the address of YT
     * @return returns the calculated yield in IBT of user
     */
    function _computeYield(
        address _user,
        uint256 _userYieldIBT,
        uint256 _oldIBTRate,
        uint256 _ibtRate,
        uint256 _oldPTRate,
        uint256 _ptRate,
        address _yt
    ) external view returns (uint256) {
        if (_oldPTRate == _ptRate && _ibtRate == _oldIBTRate) {
            return _userYieldIBT;
        }
        uint256 newYieldInIBTRay;
        uint256 userYTBalanceInRay = IYieldToken(_yt).actualBalanceOf(_user).toRay(
            IYieldToken(_yt).decimals()
        );
        // ibtOfPT is the yield generated by each PT corresponding to the YTs that the user holds
        uint256 ibtOfPTInRay = userYTBalanceInRay.mulDiv(_oldPTRate, _oldIBTRate);
        if (_oldPTRate == _ptRate && _ibtRate > _oldIBTRate) {
            // only positive yield happened
            newYieldInIBTRay = ibtOfPTInRay.mulDiv(_ibtRate - _oldIBTRate, _ibtRate);
        } else {
            if (_oldPTRate > _ptRate) {
                // PT depeg happened
                uint256 yieldInAssetRay;
                if (_ibtRate >= _oldIBTRate) {
                    // both negative and positive yield happened, more positive
                    yieldInAssetRay =
                        _convertToAssetsWithRate(
                            userYTBalanceInRay,
                            _oldPTRate - _ptRate,
                            RayMath.RAY_UNIT,
                            Math.Rounding.Floor
                        ) +
                        _convertToAssetsWithRate(
                            ibtOfPTInRay,
                            _ibtRate - _oldIBTRate,
                            RayMath.RAY_UNIT,
                            Math.Rounding.Floor
                        );
                } else {
                    // either both negative and positive yield happened, more negative
                    // or only negative yield happened
                    uint256 actualNegativeYieldInAssetRay = _convertToAssetsWithRate(
                        userYTBalanceInRay,
                        _oldPTRate - _ptRate,
                        RayMath.RAY_UNIT,
                        Math.Rounding.Floor
                    );
                    uint256 expectedNegativeYieldInAssetRay = Math.ceilDiv(
                        ibtOfPTInRay * (_oldIBTRate - _ibtRate),
                        RayMath.RAY_UNIT
                    );
                    yieldInAssetRay = expectedNegativeYieldInAssetRay >
                        actualNegativeYieldInAssetRay
                        ? 0
                        : actualNegativeYieldInAssetRay - expectedNegativeYieldInAssetRay;
                    yieldInAssetRay = yieldInAssetRay.fromRay(
                        IERC4626(IPrincipalToken(IYieldToken(_yt).getPT()).underlying()).decimals()
                    ) < SAFETY_BOUND
                        ? 0
                        : yieldInAssetRay;
                }
                newYieldInIBTRay = _convertToSharesWithRate(
                    yieldInAssetRay,
                    _ibtRate,
                    RayMath.RAY_UNIT,
                    Math.Rounding.Floor
                );
            } else {
                // PT rate increased or did not depeg on IBT rate decrease
                revert IPrincipalToken.RateError();
            }
        }
        return _userYieldIBT + newYieldInIBTRay.fromRay(IERC20Metadata(_yt).decimals());
    }

    /**
     * @dev Attempts to fetch the token decimals. Reverts if the attempt failed in some way.
     * @param _token The token address
     * @return The ERC20 token decimals
     */
    function _tryGetTokenDecimals(address _token) external view returns (uint8) {
        (bool success, bytes memory encodedDecimals) = _token.staticcall(
            abi.encodeCall(IERC20Metadata.decimals, ())
        );
        if (success && encodedDecimals.length >= 32) {
            uint256 returnedDecimals = abi.decode(encodedDecimals, (uint256));
            if (returnedDecimals <= type(uint8).max) {
                return uint8(returnedDecimals);
            }
        }
        revert AssetDoesNotImplementMetadata();
    }

    /**
     * @dev Compute tokenization fee for a given amount
     * @param _amount The amount to tokenize
     * @param _pt The address of the pt on which the fee is being paid
     * @param _registry The address of registry that stores fee rate
     * @return returns The calculated tokenization fee
     */
    function _computeTokenizationFee(
        uint256 _amount,
        address _pt,
        address _registry
    ) internal view returns (uint256) {
        return
            _amount
                .mulDiv(IRegistry(_registry).getTokenizationFee(), FEE_DIVISOR, Math.Rounding.Ceil)
                .mulDiv(
                    FEE_DIVISOR - IRegistry(_registry).getFeeReduction(_pt, msg.sender),
                    FEE_DIVISOR,
                    Math.Rounding.Ceil
                );
    }

    /**
     * @dev Compute yield fee for a given amount
     * @param _amount the amount of yield
     * @param _registry the address of registry that stores fee rate
     * @return returns the calculated yield fee
     */
    function _computeYieldFee(uint256 _amount, address _registry) internal view returns (uint256) {
        return _amount.mulDiv(IRegistry(_registry).getYieldFee(), FEE_DIVISOR, Math.Rounding.Ceil);
    }

    /**
     * @dev Compute flashloan fee for a given amount
     * @param _amount the amount to flashloan
     * @param _registry the address of registry that stores fee rate
     * @return returns the calculated flashloan fee
     */
    function _computeFlashloanFee(
        uint256 _amount,
        address _registry
    ) internal view returns (uint256) {
        return
            _amount.mulDiv(
                IRegistry(_registry).getPTFlashLoanFee(),
                FEE_DIVISOR,
                Math.Rounding.Ceil
            );
    }
}
